# sword2offer
剑指offer（专项突击版）刷题

命名方式，D3.I1表示第三天第一题。

其余命名的表示某一类型题的额外训练，huisu.I46表示回溯算法的练习，题目是leetcode题库第46题。

代码的注释中部分含有题目、题解、分析。

每天刷完后会更新到Github仓库中。

欢迎参加23届应届毕业生一起交流刷题、面试经验。


---
## 算法的学习
### 回溯算法
需要在函数里面传递两个参数，一个是路径（已经选择的），另一个是选择（未选择的）。

当路径已经满足需求的时候（通常是长度达到了限制），需要判定当前路径是否符合题目，符合则留下，不符合则
直接返回。_**注意**_：这里千万不要对路径进行任何处理，比如删除路径中的选择等，删除选择
的操作是在返回以后，由上一层函数进行的，最后一层只对路径进行判断，除此之外不做任何其他操作。
---
拿一道字节的面试题举例，使用[2,1,9,3]数组组合成一个数，找到最大的小于21563的那个数。

很明显这道题需要用回溯算法进行暴力求解。

但是这道题每次从数组中选择一个数后，还可以重复选择，因此每一次的选择，可选的都是一样的。
最后的判断条件，是目前已经选择的数是否是一个五位数即可，然后判断是否小于21563，并且更新最大值。

代码如下：
```java
public static Integer res = new Integer(Integer.MIN_VALUE);
public static void main(String[] args) {
    int[] nums = new int[]{2,5,6,9,3};
    int target = 73211563;
    // 找到使用nums组合的最大的小于target的数
    int len = String.valueOf(target).length();
    StringBuilder buffer = new StringBuilder();
    backtrack(nums, target, len, buffer);
    System.out.println(res);
}

public static void backtrack(int[] nums, int target,
                             int len, StringBuilder buffer){
    if(buffer.length() == len){
        int i = Integer.parseInt(buffer.toString());
        if(i < target){
            res = Math.max(res, i);
        }
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        buffer.append(nums[i]);
        backtrack(nums, target, len, buffer);
        buffer.deleteCharAt(buffer.length()-1);
    }
}
```
---
刚开始接触回溯算法，难免会疑惑，回溯算法会不会对同一个路径进行多次计算？
或者说会不会无限递归呢？其实不会，for循环的起始位置，以及循环体内对每一次选择的判断
会确保回溯算法刚刚好遍历完全部的选择，然后返回。

DFS算法和回溯算法在大体上是一样的，但是我们可以发现回溯算法是需要记录轨迹，到达底部就需要撤销选择，
但是DFS算法有时候不需要撤销，这是因为回溯算法需要传入轨迹，但是DFS算法有时候只需要传入当前结点的状态，可以说
在传入状态的时候，这个结点进行了分身，同时往下运行多个可能的选择，因此每达到一个底部，只需要记录最终状态即可，其他的选择
早就在传入先前状态的时候就选择了。

形象点说明，DFS是多元平行宇宙，到达一个选择点后，每一个选择都会自行开辟一个多元宇宙，最终可以在一个时间切面上同时看到所有的结果。
但是回溯算法是单一宇宙，想要知道所有选择最终的结果，需要不断的时间穿越，回到现在的结点进行选择。

当然这并不是说DFS的时间复杂度低于回溯算法，只是一个形象的比喻。

---

### 前缀和算法

对于数组nums[]，如果要得到从i到j的和，可以使用for循环，但是如果要求一个类实现快速
得到区间和的做法，那么就需要用到前缀和preSum[]，区间i到j的和，就是preSum[j]-preSum[i-1]。


如果要得到子数组之和为k的子数组的数量，这时候也可以使用前缀和
。不同于for循环，是固定左边界，前缀和方法是固定右边界。对于索引i，先求出 preSum[i]，然后我们可以知道把i当作右边界，子数组和为k的意思就是，preSum[i]-preSum[x] = k，
那么以i为右边界，和为k的子数组的数量，就是preSum[x] = preSum[i] - k的情况，有多少个符合这个条件的x，
那就有多少个子数组。

同时因为固定了右边界，我们只需要对右边界进行for循环，就可以保证不漏掉任何一个子数组。

---

### BTS
二叉搜索树，对二叉搜索数进行中序遍历，就可以得到一个有序的数组，需要注意的是，先左后右，得到的是升序，先右后左得到的是降序。
不要误会后序遍历BTS会得到降序排列。
---
### TreeSet

TreeSet是一个具有顺序的Set类。其底层是TreeMap，TreeMap底层是红黑树，所以通过传入Comparator，可以实现有序的、不重复的插入。


---
### 优先队列/堆
堆作为一种数据结构，最常用的是大根堆或者小根堆，特点是根节点是所有节点的最大值或者最小值，因此合理的控制堆的插入与删除，
可以解决最K问题。
比如对一个数组中不断插入元素，要求得到第K大的值。这时候就可以使用小根堆。

注意维护堆节点的数量的时候，为了保证根节点是插入后的第K大值，那么就要先进行插入堆操作，然后再删除根节点，因为此时的根节点是
第K+1大的值，删除后，第K大的值会自动上浮。

Java中使用了堆结构的类是优先队列`PriorityQueue`。

### HashMap

HashMap的put过程：添加一个key-value的时候，根据key的hash值得到在table中的索引，如果索引位置没有Node元素，则直接添加。
如果有Node元素，那么就比较已有Node的key值和添加元素的key值是否相等。
> 这里的相等是利用key的类的equal()来判断。

如果相等，则替换掉Node中的value，如果不相等，则向后添加一个Node节点。